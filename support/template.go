package support

import (
	"bytes"
	"gorm.io/gorm"
	"strings"
	"text/template"
)

const modelTpl = `
// Code generated by bit. DO NOT EDIT.

package model

import (
	"database/sql/driver"
	"github.com/google/uuid"
	jsoniter "github.com/json-iterator/go"
	"time"
)

type Array []interface{}

func (x *Array) Scan(input interface{}) error {
	return jsoniter.Unmarshal(input.([]byte), x)
}

func (x Array) Value() (driver.Value, error) {
	return jsoniter.Marshal(x)
}

type Object map[string]interface{}

func (x *Object) Scan(input interface{}) error {
	return jsoniter.Unmarshal(input.([]byte), x)
}

func (x Object) Value() (driver.Value, error) {
	return jsoniter.Marshal(x)
}

func True() *bool {
	value := true
	return &value
}

func False() *bool {
	return new(bool)
}

{{range .}}
type {{title .Key}} struct {` +
	"ID     	int64	  \n" +
	"Status     *bool     \n" +
	"CreateTime time.Time \n" +
	"UpdateTime time.Time  " + `
	{{columns .Columns}}
}
{{end}}
`

func GenerateModel(tx *gorm.DB) (buf bytes.Buffer, err error) {
	var schemas []Schema
	if err = tx.
		Where("kind <> ?", "manual").
		Find(&schemas).Error; err != nil {
		return
	}
	var tmpl *template.Template
	if tmpl, err = template.New("model").Funcs(template.FuncMap{
		"title":   title,
		"columns": columns,
	}).Parse(modelTpl); err != nil {
		return
	}
	if err = tmpl.Execute(&buf, schemas); err != nil {
		return
	}
	return
}

func title(s string) string {
	return strings.Title(s)
}

func typ(val string) string {
	switch val {
	case "int":
		return "int32"
	case "int8":
		return "int64"
	case "decimal":
		return "float64"
	case "float8":
		return "float64"
	case "varchar":
		return "string"
	case "text":
		return "string"
	case "bool":
		return "*bool"
	case "timestamptz":
		return "time.Time"
	case "uuid":
		return "uuid.UUID"
	case "object":
		return "Object"
	case "array":
		return "Array"
	case "rel":
		return "Array"
	}
	return val
}

func columns(columns Columns) string {
	var b strings.Builder
	for k, v := range columns {
		b.WriteString(title(k))
		b.WriteString(" ")
		b.WriteString(typ(v.Type))
		b.WriteString("\n")
	}
	return b.String()
}
